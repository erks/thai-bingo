<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡∏ö‡∏¥‡∏á‡πÇ‡∏Å‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üéØ</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+Thai:wght@400;600;700;800;900&display=swap" rel="stylesheet">
    <script src="audio.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --p1: #4361ee; --p1-light: #818cf8; --p1-bg: #eef2ff; --p1-mark: #c7d2fe;
            --p2: #e84393; --p2-light: #f472b6; --p2-bg: #fdf2f8; --p2-mark: #fbcfe8;
            --p3: #00b894; --p3-light: #34d399; --p3-bg: #ecfdf5; --p3-mark: #a7f3d0;
            --p4: #f39c12; --p4-light: #fbbf24; --p4-bg: #fffbeb; --p4-mark: #fde68a;
        }

        body {
            font-family: 'Noto Serif Thai', serif;
            background: linear-gradient(135deg, #a78bfa 0%, #7c3aed 40%, #c084fc 100%);
            min-height: 100vh;
            overflow-x: hidden;
            color: #1e1b4b;
        }

        .screen { display: flex; justify-content: center; align-items: center; min-height: 100vh; padding: 20px; }
        .hidden { display: none !important; }

        /* ====== SETUP SCREEN ====== */
        .setup-container {
            background: white; border-radius: 24px; padding: 40px;
            max-width: 520px; width: 100%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2); text-align: center;
        }
        .setup-container h1 {
            font-size: 2.2rem; font-weight: 900;
            background: linear-gradient(135deg, #7c3aed, #e84393);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
            margin-bottom: 4px;
        }
        .subtitle { color: #6b7280; font-size: 0.95rem; margin-bottom: 28px; }
        .setup-section { margin-bottom: 22px; text-align: left; }
        .setup-section > label {
            display: block; font-weight: 700; margin-bottom: 8px; font-size: 1rem; color: #4b5563;
        }

        .btn-group { display: flex; gap: 10px; flex-wrap: wrap; }
        .btn-group button {
            flex: 1; padding: 10px; border: 2px solid #e5e7eb; border-radius: 12px;
            background: white; font-family: inherit; font-size: 1rem; font-weight: 600;
            cursor: pointer; transition: all 0.2s; min-width: 80px;
        }
        .btn-group button:hover { border-color: #a78bfa; background: #f5f3ff; }
        .btn-group button.active { border-color: #7c3aed; background: #ede9fe; color: #7c3aed; }

        .name-inputs-container { display: flex; flex-direction: column; gap: 10px; }
        .name-input-row { display: flex; align-items: center; gap: 10px; }
        .name-input-row .color-dot { width: 18px; height: 18px; border-radius: 50%; flex-shrink: 0; }
        .name-input-row input {
            flex: 1; padding: 10px 14px; border: 2px solid #e5e7eb; border-radius: 12px;
            font-family: inherit; font-size: 1rem; outline: none; transition: border-color 0.2s;
        }
        .name-input-row input:focus { border-color: #7c3aed; }

        .start-button {
            width: 100%; padding: 14px; border: none; border-radius: 14px;
            background: linear-gradient(135deg, #7c3aed, #a855f7);
            color: white; font-family: inherit; font-size: 1.2rem; font-weight: 700;
            cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(124,58,237,0.4); margin-top: 10px;
        }
        .start-button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(124,58,237,0.5); }
        .start-button:active { transform: translateY(0); }

        .hint-toggle { display: flex; align-items: center; gap: 8px; margin-top: 10px; }
        .hint-toggle input { width: 18px; height: 18px; accent-color: #7c3aed; cursor: pointer; }
        .hint-toggle label { font-size: 0.9rem; color: #6b7280; cursor: pointer; }

        /* ====== GAME SCREEN ====== */
        #game-screen { flex-direction: column; align-items: center; padding: 16px; gap: 16px; }

        /* ====== CALLER SECTION ====== */
        .caller-section {
            background: white; border-radius: 20px; padding: 20px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.12);
            max-width: 900px; width: 100%;
        }

        /* Caller display row */
        .caller-row {
            display: flex; align-items: center; justify-content: center; gap: 16px;
            flex-wrap: wrap; margin-bottom: 14px;
        }

        .caller-current {
            width: 90px; height: 90px; border-radius: 50%;
            background: linear-gradient(135deg, #7c3aed, #a855f7);
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 20px rgba(124,58,237,0.3);
            flex-shrink: 0;
        }
        .caller-current span {
            font-size: 2rem; font-weight: 800; color: white; transition: all 0.3s;
        }
        .caller-current.pop span { animation: popIn 0.4s ease-out; }
        .caller-current.has-char { background: linear-gradient(135deg, #059669, #34d399); box-shadow: 0 4px 20px rgba(5,150,105,0.3); }

        @keyframes popIn {
            0% { transform: scale(0.3); opacity: 0; }
            60% { transform: scale(1.2); }
            100% { transform: scale(1); opacity: 1; }
        }

        .caller-info-col {
            display: flex; flex-direction: column; gap: 4px; align-items: center;
        }
        .caller-info { font-size: 0.85rem; color: #9ca3af; font-weight: 600; }

        /* Voice panel */
        .voice-panel { display: flex; flex-direction: column; align-items: center; gap: 12px; }

        .randomize-button {
            width: 72px; height: 72px; border-radius: 50%; border: none;
            background: linear-gradient(135deg, #7c3aed, #a855f7);
            color: white; font-size: 2rem; cursor: pointer;
            transition: all 0.2s; box-shadow: 0 4px 15px rgba(124,58,237,0.35);
            display: flex; align-items: center; justify-content: center;
        }
        .randomize-button:hover { transform: scale(1.05); box-shadow: 0 6px 20px rgba(124,58,237,0.45); }
        .randomize-button:active { transform: scale(0.97); }
        .randomize-button:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }

        .replay-button {
            padding: 10px 20px; border: none; border-radius: 12px;
            background: linear-gradient(135deg, #f59e0b, #fbbf24);
            color: white; font-family: inherit; font-size: 0.95rem; font-weight: 700;
            cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 12px rgba(245,158,11,0.3);
            animation: popIn 0.3s ease-out;
        }
        .replay-button:hover { transform: translateY(-2px); box-shadow: 0 6px 16px rgba(245,158,11,0.4); }
        .replay-button:active { transform: translateY(0); }

        .reveal-button {
            padding: 10px 28px; border: none; border-radius: 12px;
            background: linear-gradient(135deg, #059669, #34d399);
            color: white; font-family: inherit; font-size: 1rem; font-weight: 700;
            cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 12px rgba(5,150,105,0.3);
            animation: popIn 0.3s ease-out;
        }
        .reveal-button:hover { transform: translateY(-2px); box-shadow: 0 6px 16px rgba(5,150,105,0.4); }
        .reveal-button:active { transform: translateY(0); }

        .voice-status {
            font-size: 0.9rem; font-weight: 600; min-height: 1.4em; text-align: center;
            color: #6b7280; transition: color 0.2s;
        }
        .voice-status.error { color: #ef4444; }
        .voice-status.success { color: #059669; }

        /* Called history */
        .called-history-section { border-top: 1px solid #f3f4f6; padding-top: 10px; }
        .called-history {
            display: flex; flex-wrap: wrap; gap: 6px;
            max-height: 80px; overflow-y: auto;
        }
        .called-chip {
            display: inline-flex; align-items: center; justify-content: center;
            padding: 3px 10px; border-radius: 8px; font-size: 0.85rem; font-weight: 600;
            background: #f3f4f6; color: #6b7280; animation: chipIn 0.3s ease-out;
        }
        .called-chip.consonant { background: #ede9fe; color: #6d28d9; }
        .called-chip.vowel { background: #fce7f3; color: #be185d; }
        @keyframes chipIn {
            0% { transform: scale(0); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* ====== BOARDS ====== */
        .boards-container {
            display: flex; flex-wrap: wrap; justify-content: center; gap: 16px;
            max-width: 1200px; width: 100%;
        }
        .board-card {
            background: white; border-radius: 16px; padding: 12px;
            box-shadow: 0 6px 24px rgba(0,0,0,0.1); flex: 0 1 auto; min-width: 260px;
        }
        .players-2 .board-card { width: calc(50% - 8px); max-width: 380px; }
        .players-3 .board-card { width: calc(33.33% - 12px); max-width: 320px; }
        .players-4 .board-card { width: calc(50% - 8px); max-width: 320px; }

        .board-header {
            text-align: center; padding: 8px; border-radius: 10px; margin-bottom: 10px;
            font-weight: 700; font-size: 1rem; color: white;
        }
        .board-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; }

        .cell {
            aspect-ratio: 1; border-radius: 8px; border: 2px solid #e5e7eb;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.15rem; font-weight: 700; cursor: pointer;
            transition: all 0.15s; position: relative; background: white;
            user-select: none; -webkit-user-select: none; line-height: 1.1;
        }
        .cell:hover:not(.marked):not(.free) { transform: scale(1.05); border-color: #a78bfa; }
        .cell.free {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            border-color: #f59e0b; cursor: default; font-size: 1.3rem;
        }
        .cell.marked { border-color: transparent; transform: scale(1); cursor: default; }
        .cell.marked::after {
            content: ''; position: absolute; inset: 3px; border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.6); pointer-events: none;
        }
        .cell.mark-anim { animation: markPop 0.35s ease-out; }
        @keyframes markPop { 0% { transform: scale(1); } 40% { transform: scale(1.15); } 100% { transform: scale(1); } }

        .cell.hint-pulse { animation: hintPulse 1.5s ease-in-out infinite; }
        @keyframes hintPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(124,58,237,0); }
            50% { box-shadow: 0 0 0 5px rgba(124,58,237,0.25); }
        }
        .cell.win-glow { animation: winGlow 0.8s ease-in-out infinite alternate; z-index: 2; }
        @keyframes winGlow {
            0% { box-shadow: 0 0 8px 2px rgba(250,204,21,0.4); }
            100% { box-shadow: 0 0 16px 6px rgba(250,204,21,0.8); }
        }
        .cell.selected {
            border-color: #a78bfa; background: #ede9fe;
            box-shadow: 0 0 0 2px rgba(124,58,237,0.3);
        }
        .cell.wrong { animation: shake 0.3s ease-in-out; }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-4px); }
            75% { transform: translateX(4px); }
        }

        /* Player-specific colors */
        .p0 .board-header { background: linear-gradient(135deg, var(--p1), var(--p1-light)); }
        .p0 .cell.marked { background: var(--p1-mark); color: var(--p1); border-color: var(--p1-light); }
        .p1 .board-header { background: linear-gradient(135deg, var(--p2), var(--p2-light)); }
        .p1 .cell.marked { background: var(--p2-mark); color: var(--p2); border-color: var(--p2-light); }
        .p2 .board-header { background: linear-gradient(135deg, var(--p3), var(--p3-light)); }
        .p2 .cell.marked { background: var(--p3-mark); color: var(--p3); border-color: var(--p3-light); }
        .p3 .board-header { background: linear-gradient(135deg, var(--p4), var(--p4-light)); }
        .p3 .cell.marked { background: var(--p4-mark); color: var(--p4); border-color: var(--p4-light); }

        /* ====== BOTTOM CONTROLS ====== */
        .bottom-controls { display: flex; gap: 12px; }
        .ctrl-btn {
            padding: 10px 24px; border: 2px solid rgba(255,255,255,0.4); border-radius: 12px;
            background: rgba(255,255,255,0.15); color: white;
            font-family: inherit; font-size: 0.95rem; font-weight: 600;
            cursor: pointer; transition: all 0.2s; backdrop-filter: blur(4px);
        }
        .ctrl-btn:hover { background: rgba(255,255,255,0.25); border-color: rgba(255,255,255,0.6); }

        /* ====== LANGUAGE TOGGLE ====== */
        .lang-toggle {
            position: absolute; top: 12px; right: 12px;
            padding: 4px 12px; border: 2px solid #e5e7eb; border-radius: 20px;
            background: white; font-family: inherit; font-size: 0.8rem; font-weight: 700;
            color: #6b7280; cursor: pointer; transition: all 0.2s;
        }
        .lang-toggle:hover { border-color: #a78bfa; color: #7c3aed; }
        .setup-container { position: relative; }
        .bottom-controls .lang-toggle { position: static; background: rgba(255,255,255,0.15); color: white; border-color: rgba(255,255,255,0.4); }
        .bottom-controls .lang-toggle:hover { background: rgba(255,255,255,0.25); border-color: rgba(255,255,255,0.6); }

        /* ====== WIN OVERLAY ====== */
        .win-overlay {
            position: fixed; inset: 0; z-index: 1000;
            display: flex; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.5); backdrop-filter: blur(4px);
        }
        .win-overlay canvas { position: absolute; inset: 0; pointer-events: none; }
        .win-content {
            background: white; border-radius: 24px; padding: 40px 50px;
            text-align: center; z-index: 1001;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3); animation: popIn 0.5s ease-out;
        }
        .win-content h2 {
            font-size: 2.2rem; font-weight: 900;
            background: linear-gradient(135deg, #f59e0b, #ef4444, #ec4899);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
        }
        .win-content .winner-name { font-size: 1.5rem; font-weight: 700; margin: 12px 0 24px; color: #4b5563; }
        .win-buttons { display: flex; gap: 12px; justify-content: center; }
        .win-buttons button {
            padding: 12px 28px; border: none; border-radius: 12px;
            font-family: inherit; font-size: 1rem; font-weight: 600; cursor: pointer; transition: transform 0.15s;
        }
        .win-buttons button:first-child {
            background: linear-gradient(135deg, #7c3aed, #a855f7); color: white;
            box-shadow: 0 4px 12px rgba(124,58,237,0.3);
        }
        .win-buttons button:last-child { background: #f3f4f6; color: #4b5563; }
        .win-buttons button:hover { transform: translateY(-2px); }

        /* ====== ONLINE MODE ====== */
        .room-code-display {
            font-family: monospace; font-size: 3rem; font-weight: 900;
            letter-spacing: 0.3em; text-align: center;
            background: linear-gradient(135deg, #7c3aed, #a855f7);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;
            margin: 16px 0 8px;
        }
        .lobby-container {
            background: white; border-radius: 24px; padding: 40px;
            max-width: 520px; width: 100%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2); text-align: center;
        }
        .lobby-container h2 {
            font-size: 1.5rem; font-weight: 800; color: #4b5563; margin-bottom: 4px;
        }
        .lobby-subtitle { color: #9ca3af; font-size: 0.9rem; margin-bottom: 16px; }
        .share-link-row {
            display: flex; align-items: center; gap: 8px; justify-content: center;
            margin-bottom: 20px;
        }
        .share-link-row input {
            flex: 1; max-width: 320px; padding: 8px 12px; border: 2px solid #e5e7eb;
            border-radius: 10px; font-family: monospace; font-size: 0.85rem;
            color: #6b7280; text-align: center; outline: none;
        }
        .copy-btn {
            padding: 8px 14px; border: 2px solid #e5e7eb; border-radius: 10px;
            background: white; font-family: inherit; font-size: 0.85rem; font-weight: 600;
            cursor: pointer; transition: all 0.2s; color: #6b7280;
        }
        .copy-btn:hover { border-color: #a78bfa; color: #7c3aed; }
        .copy-btn.copied { border-color: #059669; color: #059669; }
        .player-list {
            text-align: left; margin: 16px 0; min-height: 40px;
        }
        .moderator-play-toggle {
            display: flex; align-items: center; justify-content: center; gap: 12px;
            padding: 14px 20px; border-radius: 14px; border: 2px solid #e5e7eb;
            background: white; margin: 16px 0; cursor: pointer;
            transition: all 0.2s; user-select: none;
        }
        .moderator-play-toggle:hover { border-color: #a78bfa; background: #f5f3ff; }
        .moderator-play-toggle.active { border-color: #7c3aed; background: #ede9fe; }
        .moderator-play-toggle input[type="checkbox"] {
            width: 22px; height: 22px; accent-color: #7c3aed; cursor: pointer;
        }
        .moderator-play-toggle label {
            font-size: 1.05rem; font-weight: 700; color: #4b5563; cursor: pointer; margin: 0;
        }
        .moderator-play-toggle.active label { color: #7c3aed; }
        .player-list-item {
            display: flex; align-items: center; gap: 10px; padding: 8px 12px;
            border-radius: 10px; animation: chipIn 0.3s ease-out; margin-bottom: 4px;
        }
        .player-list-item .color-dot { width: 14px; height: 14px; border-radius: 50%; flex-shrink: 0; }
        .player-list-item .player-name { font-weight: 600; font-size: 0.95rem; }
        .player-list-item .you-badge {
            font-size: 0.75rem; font-weight: 700; color: #7c3aed;
            background: #ede9fe; padding: 2px 8px; border-radius: 8px;
        }
        .player-list-item .connection-dot {
            width: 8px; height: 8px; border-radius: 50%; margin-left: auto;
        }
        .connection-dot.online { background: #22c55e; }
        .connection-dot.offline { background: #d1d5db; }
        .status-banner {
            background: white; border-radius: 14px; padding: 12px 20px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.08);
            max-width: 900px; width: 100%; text-align: center;
            font-weight: 700; font-size: 1rem; color: #6b7280;
        }
        .status-banner.pending { color: #f59e0b; }
        .status-banner.selecting { color: #7c3aed; }
        .status-banner.revealed { color: #059669; }
        .online-setup-section { margin-bottom: 16px; text-align: left; }
        .online-setup-section > label {
            display: block; font-weight: 700; margin-bottom: 8px; font-size: 1rem; color: #4b5563;
        }
        .online-setup-section input[type="text"] {
            width: 100%; padding: 10px 14px; border: 2px solid #e5e7eb; border-radius: 12px;
            font-family: inherit; font-size: 1rem; outline: none; transition: border-color 0.2s;
        }
        .online-setup-section input[type="text"]:focus { border-color: #7c3aed; }
        .room-code-input {
            font-family: monospace !important; font-size: 1.8rem !important; font-weight: 900 !important;
            text-align: center !important; letter-spacing: 0.15em !important; text-transform: uppercase;
        }

        /* Online board layout */
        .boards-container.online-player { flex-direction: column; align-items: center; }
        .boards-container.online-player .board-card.primary {
            width: 100%; max-width: 420px;
        }
        .boards-container.online-player .board-card.secondary {
            width: calc(33.33% - 12px); max-width: 200px; min-width: 160px;
        }
        .boards-container.online-player .board-card.secondary .cell { font-size: 0.8rem; cursor: default; }
        .boards-container.online-player .board-card.secondary .cell:hover { transform: none; border-color: #e5e7eb; }
        .secondary-boards-row {
            display: flex; flex-wrap: wrap; justify-content: center; gap: 12px; width: 100%;
        }

        /* ====== READY BUTTON & INDICATORS ====== */
        .ready-button {
            width: 100%; max-width: 420px; padding: 12px; border: 2px solid #7c3aed; border-radius: 14px;
            background: white; color: #7c3aed; font-family: inherit; font-size: 1.05rem; font-weight: 700;
            cursor: pointer; transition: all 0.2s; margin-top: 0;
        }
        .ready-button:hover { background: #f5f3ff; }
        .ready-button.active {
            background: linear-gradient(135deg, #7c3aed, #a855f7); color: white;
            border-color: #7c3aed; box-shadow: 0 4px 12px rgba(124,58,237,0.3);
        }
        .ready-badge {
            display: inline-block; font-size: 0.7rem; margin-left: 6px;
            background: #7c3aed; color: white; padding: 1px 6px; border-radius: 6px;
            vertical-align: middle; font-weight: 700;
        }
        .board-card.player-ready { box-shadow: 0 0 0 2px #7c3aed, 0 6px 24px rgba(124,58,237,0.2); }
        .ready-info {
            font-size: 0.85rem; font-weight: 700; color: #7c3aed;
            text-align: center; padding: 4px 0;
        }

        /* ====== RESPONSIVE ====== */
        @media (max-width: 900px) {
            .players-3 .board-card { width: calc(50% - 8px); }
            .cell { font-size: 1rem; }
        }
        @media (max-width: 600px) {
            .setup-container { padding: 24px; }
            .setup-container h1 { font-size: 1.6rem; }
            .board-card { min-width: 220px; }
            .players-2 .board-card, .players-3 .board-card, .players-4 .board-card { width: 100%; max-width: 360px; }
            .cell { font-size: 0.9rem; border-radius: 6px; }
            .caller-current { width: 72px; height: 72px; }
            .caller-current span { font-size: 1.6rem; }
            .randomize-button { width: 60px; height: 60px; font-size: 1.6rem; }
        }
    </style>
</head>
<body>

<!-- ====== SETUP SCREEN ====== -->
<div id="setup-screen" class="screen">
    <div class="setup-container">
        <button class="lang-toggle" onclick="setLang(state.lang==='th'?'en':'th')">EN</button>
        <h1>üéØ <span data-i18n="title">‡∏ö‡∏¥‡∏á‡πÇ‡∏Å‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢</span></h1>
        <p class="subtitle" data-i18n="subtitle">‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡πÑ‡∏ó‡∏¢‡πÅ‡∏™‡∏ô‡∏™‡∏ô‡∏∏‡∏Å!</p>

        <div class="setup-section">
            <label data-i18n="playerCount">‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô</label>
            <div class="btn-group" id="player-count-btns"></div>
        </div>

        <div class="setup-section">
            <label data-i18n="playerNames">‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô</label>
            <div class="name-inputs-container" id="name-inputs"></div>
        </div>

        <div class="setup-section">
            <label data-i18n="mode">‡πÇ‡∏´‡∏°‡∏î</label>
            <div class="btn-group" id="mode-btns"></div>
        </div>

        <div class="hint-toggle">
            <input type="checkbox" id="hints-check" checked>
            <label for="hints-check" data-i18n="hintsLabel">‡πÄ‡∏õ‡∏¥‡∏î‡∏Ñ‡∏≥‡πÉ‡∏ö‡πâ (‡∏ä‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏à‡∏∞‡∏Å‡∏£‡∏∞‡∏û‡∏£‡∏¥‡∏ö)</label>
        </div>

        <button class="start-button" onclick="startGame()" data-i18n="startGame">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°! üéÆ</button>
    </div>
</div>

<!-- ====== LOBBY SCREEN ====== -->
<div id="lobby-screen" class="screen hidden">
    <div class="lobby-container">
        <h2 id="lobby-title"></h2>
        <div class="room-code-display" id="lobby-room-code"></div>
        <div class="lobby-subtitle" id="lobby-subtitle"></div>
        <div class="share-link-row" id="share-link-row">
            <input type="text" id="share-link-input" readonly>
            <button class="copy-btn" id="copy-link-btn" onclick="copyShareLink()"></button>
        </div>
        <div class="moderator-play-toggle hidden" id="moderator-play-toggle" onclick="toggleModeratorPlaying(event)">
            <input type="checkbox" id="lobby-moderator-plays">
            <label for="lobby-moderator-plays" data-i18n="moderatorPlays">I'm playing too</label>
        </div>
        <div class="player-list" id="lobby-player-list"></div>
        <button class="start-button" id="lobby-start-btn" onclick="onlineStartGame()" disabled></button>
        <p id="lobby-waiting-msg" class="hidden" style="color:#9ca3af; margin-top:12px; font-weight:600;"></p>
    </div>
</div>

<!-- ====== GAME SCREEN ====== -->
<div id="game-screen" class="screen hidden">
    <div class="caller-section">
        <div class="caller-row">
            <!-- Calling controls -->
            <div class="voice-panel">
                <button class="randomize-button" id="random-btn" onclick="randomizeChar()">üé≤</button>
                <div style="display:flex; gap:8px;">
                    <button class="replay-button hidden" id="replay-btn" onclick="replayChar()" data-i18n="replay">üîä ‡∏ü‡∏±‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</button>
                    <button class="reveal-button hidden" id="reveal-btn" onclick="revealChar()" data-i18n="reveal">‡πÄ‡∏â‡∏•‡∏¢</button>
                </div>
                <div class="voice-status" id="voice-status" data-status-key="statusReady">‡∏Å‡∏î‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°</div>
            </div>

            <!-- Current character display -->
            <div class="caller-current" id="caller-display">
                <span id="current-char">?</span>
            </div>

            <!-- Info column -->
            <div class="caller-info-col">
                <div class="caller-info"><span id="draw-count">0</span> / <span id="total-count">0</span></div>
            </div>
        </div>

        <div class="called-history-section">
            <div class="called-history" id="called-history"></div>
        </div>
    </div>

    <div id="boards-container" class="boards-container"></div>

    <div class="bottom-controls">
        <button class="ctrl-btn" onclick="backToSetup()" data-i18n="settings">‚öôÔ∏è ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤</button>
        <button class="ctrl-btn" onclick="resetGame()" data-i18n="newGame">üîÑ ‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà</button>
        <button class="ctrl-btn lang-toggle" onclick="setLang(state.lang==='th'?'en':'th')">EN</button>
    </div>
</div>

<!-- ====== WIN OVERLAY ====== -->
<div id="win-overlay" class="win-overlay hidden">
    <canvas id="confetti-canvas"></canvas>
    <div class="win-content">
        <h2 data-i18n="bingo">üéâ ‡∏ö‡∏¥‡∏á‡πÇ‡∏Å! üéâ</h2>
        <p class="winner-name" id="winner-name"></p>
        <div class="win-buttons">
            <button onclick="continueAfterWin()" data-i18n="continue">‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠</button>
            <button onclick="resetGame()" data-i18n="newGame">‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà</button>
        </div>
    </div>
</div>

<script>
// ============================================================
// DATA
// ============================================================
const CONSONANTS = [
    '‡∏Å','‡∏Ç','‡∏É','‡∏Ñ','‡∏Ö','‡∏Ü','‡∏á','‡∏à','‡∏â','‡∏ä','‡∏ã','‡∏å','‡∏ç','‡∏é','‡∏è',
    '‡∏ê','‡∏ë','‡∏í','‡∏ì','‡∏î','‡∏ï','‡∏ñ','‡∏ó','‡∏ò','‡∏ô','‡∏ö','‡∏õ','‡∏ú','‡∏ù','‡∏û',
    '‡∏ü','‡∏†','‡∏°','‡∏¢','‡∏£','‡∏•','‡∏ß','‡∏®','‡∏©','‡∏™','‡∏´','‡∏¨','‡∏≠','‡∏Æ'
];

const VOWELS = [
    '-‡∏∞', '-‡∏≤', '-‡∏¥', '-‡∏µ', '-‡∏∂', '-‡∏∑', '-‡∏∏', '-‡∏π',
    '‡πÄ-', '‡πÄ-‡∏∞', '‡πÅ-', '‡πÅ-‡∏∞', '‡πÇ-', '‡πÇ-‡∏∞',
    '‡πÄ-‡∏≤‡∏∞', '-‡∏≠', '‡πÄ-‡∏≠‡∏∞', '‡πÄ-‡∏≠',
    '‡πÄ-‡∏µ‡∏¢‡∏∞', '‡πÄ-‡∏µ‡∏¢', '‡πÄ-‡∏∑‡∏≠‡∏∞', '‡πÄ-‡∏∑‡∏≠', '-‡∏±‡∏ß‡∏∞', '-‡∏±‡∏ß',
    '‡πÉ-', '‡πÑ-', '-‡∏≥', '‡πÄ-‡∏≤',
    '-‡∏£‡∏£', '‡∏§', '‡∏§‡πÖ'
];

const PLAYER_COLORS = ['#4361ee', '#e84393', '#00b894', '#f39c12'];
const GAME_POOL_SIZES = { consonants: 35, vowels: 31, mixed: 42 };

// ============================================================
// I18N
// ============================================================
const STRINGS = {
    th: {
        title: '‡∏ö‡∏¥‡∏á‡πÇ‡∏Å‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢',
        subtitle: '‡πÄ‡∏£‡∏µ‡∏¢‡∏ô‡∏£‡∏π‡πâ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡πÑ‡∏ó‡∏¢‡πÅ‡∏™‡∏ô‡∏™‡∏ô‡∏∏‡∏Å!',
        playerCount: '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô',
        playerNames: '‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô',
        mode: '‡πÇ‡∏´‡∏°‡∏î',
        modeConsonants: '‡∏û‡∏¢‡∏±‡∏ç‡∏ä‡∏ô‡∏∞',
        modeVowels: '‡∏™‡∏£‡∏∞',
        modeMixed: '‡∏ú‡∏™‡∏°',
        hintsLabel: '‡πÄ‡∏õ‡∏¥‡∏î‡∏Ñ‡∏≥‡πÉ‡∏ö‡πâ (‡∏ä‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏á‡∏à‡∏∞‡∏Å‡∏£‡∏∞‡∏û‡∏£‡∏¥‡∏ö)',
        startGame: '‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°! üéÆ',
        playerUnit: '‡∏Ñ‡∏ô',
        defaultPlayer: '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô',
        replay: 'üîä ‡∏ü‡∏±‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á',
        reveal: '‡πÄ‡∏â‡∏•‡∏¢',
        settings: '‚öôÔ∏è ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤',
        newGame: 'üîÑ ‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà',
        bingo: 'üéâ ‡∏ö‡∏¥‡∏á‡πÇ‡∏Å! üéâ',
        continue: '‡πÄ‡∏•‡πà‡∏ô‡∏ï‡πà‡∏≠',
        statusReady: '‡∏Å‡∏î‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°',
        statusPending: '‡∏Å‡∏î ‡πÄ‡∏â‡∏•‡∏¢ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡∏¥‡∏î ‡∏´‡∏£‡∏∑‡∏≠ ‡∏ü‡∏±‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á',
        statusNext: '‡∏Å‡∏î‡∏™‡∏∏‡πà‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏ï‡∏±‡∏ß‡∏ñ‡∏±‡∏î‡πÑ‡∏õ',
        statusEmpty: '‡∏´‡∏°‡∏î‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡πÅ‡∏•‡πâ‡∏ß',
        // Online mode
        gameTypeLocal: '‡πÄ‡∏•‡πà‡∏ô‡∏î‡πâ‡∏ß‡∏¢‡∏Å‡∏±‡∏ô',
        gameTypeOnline: '‡∏≠‡∏≠‡∏ô‡πÑ‡∏•‡∏ô‡πå',
        gameType: '‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡πÄ‡∏Å‡∏°',
        createRoom: '‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡πâ‡∏≠‡∏á',
        joinRoom: '‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°',
        onlineRole: '‡∏ö‡∏ó‡∏ö‡∏≤‡∏ó',
        moderatorName: '‡∏ä‡∏∑‡πà‡∏≠‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì',
        moderatorPlays: '‡∏â‡∏±‡∏ô‡πÄ‡∏•‡πà‡∏ô‡∏î‡πâ‡∏ß‡∏¢',
        createRoomBtn: '‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡πâ‡∏≠‡∏á',
        roomCodeLabel: '‡∏£‡∏´‡∏±‡∏™‡∏´‡πâ‡∏≠‡∏á',
        roomCodePlaceholder: '‡πÄ‡∏ä‡πà‡∏ô A3BK7P',
        joinName: '‡∏ä‡∏∑‡πà‡∏≠‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì',
        joinBtn: '‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°',
        yourRoom: '‡∏´‡πâ‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì',
        shareLink: '‡πÅ‡∏ä‡∏£‡πå‡∏•‡∏¥‡∏á‡∏Å‡πå',
        copyLink: '‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å',
        linkCopied: '‡∏Ñ‡∏±‡∏î‡∏•‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß!',
        waitingForPlayers: '‡∏£‡∏≠‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°...',
        lobbyPlayerCount: '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô {n} ‡∏Ñ‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°‡πÅ‡∏•‡πâ‡∏ß',
        startGameOnline: '‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°!',
        playersJoined: '‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô',
        minPlayersNeeded: '‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 1 ‡∏Ñ‡∏ô',
        you: '‡∏Ñ‡∏∏‡∏ì',
        waitingForModerator: '‡∏£‡∏≠‡∏ú‡∏π‡πâ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡πÄ‡∏Å‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°...',
        youJoinedAs: '‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏Ç‡πâ‡∏≤‡∏£‡πà‡∏ß‡∏°‡πÉ‡∏ô‡∏ä‡∏∑‡πà‡∏≠',
        statusModeratorRandomizing: '‡∏ú‡∏π‡πâ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡πÄ‡∏Å‡∏°‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡∏∏‡πà‡∏°...',
        statusSelectYourCell: '‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡πà‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì!',
        statusWaitingReveal: '‡∏£‡∏≠‡πÄ‡∏â‡∏•‡∏¢...',
        statusCharRevealed: '‡πÄ‡∏â‡∏•‡∏¢‡πÅ‡∏•‡πâ‡∏ß!',
        readyBtn: '‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÅ‡∏•‡πâ‡∏ß!',
        readyStatus: '‡∏û‡∏£‡πâ‡∏≠‡∏°',
        playersReady: '{n}/{total} ‡∏Ñ‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÅ‡∏•‡πâ‡∏ß',
        playerDisconnected: '‡∏´‡∏•‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠',
        moderatorDisconnected: '‡∏ú‡∏π‡πâ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡πÄ‡∏Å‡∏°‡∏´‡∏•‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠',
        reconnecting: '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÉ‡∏´‡∏°‡πà...',
        errorRoomNotFound: '‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏´‡πâ‡∏≠‡∏á',
        errorConnection: '‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ',
        connecting: '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠...',
    },
    en: {
        title: 'Thai Alphabet Bingo',
        subtitle: 'Learn Thai letters through bingo!',
        playerCount: 'Number of players',
        playerNames: 'Player names',
        mode: 'Mode',
        modeConsonants: 'Consonants',
        modeVowels: 'Vowels',
        modeMixed: 'Mixed',
        hintsLabel: 'Enable hints (matching cells pulse)',
        startGame: 'Start Game! üéÆ',
        playerUnit: 'players',
        defaultPlayer: 'Player',
        replay: 'üîä Replay',
        reveal: 'Reveal',
        settings: '‚öôÔ∏è Settings',
        newGame: 'üîÑ New Game',
        bingo: 'üéâ Bingo! üéâ',
        continue: 'Continue',
        statusReady: 'Press randomize to start',
        statusPending: 'Press Reveal or Replay',
        statusNext: 'Press randomize for next',
        statusEmpty: 'No characters left',
        // Online mode
        gameTypeLocal: 'Local',
        gameTypeOnline: 'Online',
        gameType: 'Game type',
        createRoom: 'Create Room',
        joinRoom: 'Join Room',
        onlineRole: 'Role',
        moderatorName: 'Your name',
        moderatorPlays: "I'm playing too",
        createRoomBtn: 'Create Room',
        roomCodeLabel: 'Room code',
        roomCodePlaceholder: 'e.g. A3BK7P',
        joinName: 'Your name',
        joinBtn: 'Join',
        yourRoom: 'Your room',
        shareLink: 'Share link',
        copyLink: 'Copy',
        linkCopied: 'Copied!',
        waitingForPlayers: 'Waiting for players...',
        lobbyPlayerCount: '{n} player(s) joined',
        startGameOnline: 'Start Game!',
        playersJoined: 'Players',
        minPlayersNeeded: 'Need at least 1 player',
        you: 'You',
        waitingForModerator: 'Waiting for moderator to start...',
        youJoinedAs: 'You joined as',
        statusModeratorRandomizing: 'Moderator is picking...',
        statusSelectYourCell: 'Select your cell!',
        statusWaitingReveal: 'Waiting for reveal...',
        statusCharRevealed: 'Revealed!',
        readyBtn: "I'm ready!",
        readyStatus: 'Ready',
        playersReady: '{n}/{total} ready',
        playerDisconnected: 'Disconnected',
        moderatorDisconnected: 'Moderator disconnected',
        reconnecting: 'Reconnecting...',
        errorRoomNotFound: 'Room not found',
        errorConnection: 'Connection failed',
        connecting: 'Connecting...',
    }
};

function t(key) { return STRINGS[state.lang][key]; }

function setLang(lang) {
    state.lang = lang;
    localStorage.setItem('lang', lang);
    applyLang();
}

function applyLang() {
    document.querySelectorAll('[data-i18n]').forEach(el => {
        el.textContent = t(el.dataset.i18n);
    });
    // Re-render dynamic setup buttons
    initSetup();
    // Update lang toggle labels
    document.querySelectorAll('.lang-toggle').forEach(btn => {
        btn.textContent = state.lang === 'th' ? 'EN' : 'TH';
    });
    // Re-translate voice status if a key is stored
    const vs = document.getElementById('voice-status');
    if (vs && vs.dataset.statusKey) {
        vs.textContent = t(vs.dataset.statusKey);
    }
    // Re-render lobby if visible
    if (!document.getElementById('lobby-screen').classList.contains('hidden')) {
        showLobby();
    }
    // Re-render online status banner if visible
    if (typeof renderOnlineStatusBanner === 'function' && state.gameType === 'online' && state.onlinePhase === 'playing') {
        renderOnlineStatusBanner();
    }
}

// ============================================================
// STATE
// ============================================================
const API_BASE = (location.hostname === 'localhost' || location.hostname === '127.0.0.1')
    ? 'http://localhost:8787'
    : 'https://thai-bingo-api.erks.workers.dev';

let state = {
    lang: localStorage.getItem('lang') || 'th',
    playerCount: 2,
    mode: 'mixed',
    hintsOn: true,
    players: [],
    boards: [],
    gamePool: [],
    calledChars: [],
    currentChar: null,
    gameActive: false,
    winners: [],
    confettiId: null,
    pendingChar: null,
    pendingSelections: {},
    // Online mode
    gameType: 'local',         // 'local' or 'online'
    onlineRole: 'create',      // 'create' or 'join' (setup choice)
    role: null,                // 'moderator' or 'player' (in-game)
    moderatorPlaying: false,
    ws: null,
    playerId: null,
    roomCode: null,
    onlinePlayers: [],
    allBoards: {},             // {playerId: board}
    myBoardId: null,
    onlinePhase: null,         // 'lobby' | 'playing'
    pendingReadyIds: [],
    isReady: false,
};

// ============================================================
// AUDIO
// ============================================================
let audioCtx = null;
function ensureAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
    // Play a silent tone to unlock audio
    if (audioCtx.currentTime < 0.1) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        gain.gain.value = 0.001; // Almost silent
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.01);
    }
}
function playTone(freq, dur, vol = 0.2, type = 'sine') {
    ensureAudio();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type; osc.frequency.value = freq;
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + dur);
}
function sfxCall() { playTone(587, 0.15, 0.2); setTimeout(() => playTone(784, 0.15, 0.2), 100); }
function sfxMark() { playTone(880, 0.12, 0.15); }
function sfxWrong() { playTone(200, 0.15, 0.15, 'square'); }
function sfxWin() { [523, 659, 784, 1047].forEach((f, i) => setTimeout(() => playTone(f, 0.2, 0.25), i * 140)); }

// ============================================================
// UTILITIES
// ============================================================
function shuffle(arr) {
    const a = [...arr];
    for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
}
function isVowel(ch) { return VOWELS.includes(ch); }

// ============================================================
// AUDIO PLAYBACK (pre-recorded native speaker from thai-alphabet.com)
// ============================================================
const CHAR_AUDIO_KEY = {
    '‡∏Å': 'consonant-ko-kai', '‡∏Ç': 'consonant-kho-khay',
    '‡∏Ñ': 'consonant-kho-khwai', '‡∏Ü': 'consonant-kho-rakhang',
    '‡∏á': 'consonant-ngo-ngu', '‡∏à': 'consonant-jo-jan',
    '‡∏â': 'consonant-cho-ching', '‡∏ä': 'consonant-cho-chang',
    '‡∏ã': 'consonant-so-so', '‡∏å': 'consonant-cho-cho',
    '‡∏ç': 'consonant-yo-ying', '‡∏é': 'consonant-do-chada',
    '‡∏è': 'consonant-to-patak', '‡∏ê': 'consonant-tho-than',
    '‡∏ë': 'consonant-tho-montho', '‡∏í': 'consonant-tho-phuthau',
    '‡∏ì': 'consonant-no-nen', '‡∏î': 'consonant-do-dek',
    '‡∏ï': 'consonant-to-tau', '‡∏ñ': 'consonant-tho-thung',
    '‡∏ó': 'consonant-tho-thahan', '‡∏ò': 'consonant-tho-thong',
    '‡∏ô': 'consonant-no-nu', '‡∏ö': 'consonant-bo-baimai',
    '‡∏õ': 'consonant-po-pla', '‡∏ú': 'consonant-pho-phing',
    '‡∏ù': 'consonant-fo-fa', '‡∏û': 'consonant-pho-phan',
    '‡∏ü': 'consonant-fo-fan', '‡∏†': 'consonant-pho-samphau',
    '‡∏°': 'consonant-mo-ma', '‡∏¢': 'consonant-yo-yak',
    '‡∏£': 'consonant-ro-ria', '‡∏•': 'consonant-lo-ling',
    '‡∏ß': 'consonant-wo-weng', '‡∏®': 'consonant-so-sala',
    '‡∏©': 'consonant-so-risi', '‡∏™': 'consonant-so-sia',
    '‡∏´': 'consonant-ho-hip', '‡∏¨': 'consonant-lo-jula',
    '‡∏≠': 'consonant-o-ang', '‡∏Æ': 'consonant-ho-nokhu',
    '-‡∏∞': 'sara-a-short', '-‡∏≤': 'sara-a-long',
    '-‡∏¥': 'sara-i-short', '-‡∏µ': 'sara-i-long',
    '-‡∏∂': 'sara-eu-short', '-‡∏∑': 'sara-eu-long',
    '-‡∏∏': 'sara-u-short', '-‡∏π': 'sara-u-long',
    '‡πÄ-': 'sara-e-long', '‡πÄ-‡∏∞': 'sara-e-short',
    '‡πÅ-': 'sara-ae-long', '‡πÅ-‡∏∞': 'sara-ae-short',
    '‡πÇ-': 'sara-o-long', '‡πÇ-‡∏∞': 'sara-o-short',
    '‡πÄ-‡∏≤‡∏∞': 'sara-aw-short', '-‡∏≠': 'sara-aw-long',
    '‡πÄ-‡∏≠‡∏∞': 'sara-uh-short', '‡πÄ-‡∏≠': 'sara-uh-long',
    '‡πÄ-‡∏µ‡∏¢‡∏∞': 'sara-ia-short', '‡πÄ-‡∏µ‡∏¢': 'sara-ia-long',
    '‡πÄ-‡∏∑‡∏≠‡∏∞': 'sara-eua-short', '‡πÄ-‡∏∑‡∏≠': 'sara-eua-long',
    '-‡∏±‡∏ß‡∏∞': 'sara-ua-short', '-‡∏±‡∏ß': 'sara-ua-long',
    '‡πÉ-': 'sara-ay-may-muan', '‡πÑ-': 'sara-ay-may-malay',
    '-‡∏≥': 'sara-am', '‡πÄ-‡∏≤': 'sara-au',
    '-‡∏£‡∏£': 'sara-an-rohan', '‡∏§': 'sara-reu-short', '‡∏§‡πÖ': 'sara-reu-long',
};

let charVoiceover = null;

const CHAR_TTS = {
    '‡∏É': '‡∏Ç‡∏≠ ‡∏É‡∏ß‡∏î',
    '‡∏Ö': '‡∏Ñ‡∏≠ ‡∏Ñ‡∏ô',
};

function speakChar(char) {
    if (charVoiceover) {
        charVoiceover.pause();
        charVoiceover.currentTime = 0;
    }
    window.speechSynthesis.cancel();
    const key = CHAR_AUDIO_KEY[char];
    if (key && typeof AUDIO_DATA !== 'undefined' && AUDIO_DATA.has(key)) {
        charVoiceover = new Audio('data:audio/mpeg;base64,' + AUDIO_DATA.get(key));
        charVoiceover.play().catch(err => {
            console.log('Audio playback blocked, falling back to speech synthesis:', err);
            // Fallback to speech synthesis
            if (CHAR_TTS[char]) {
                const utt = new SpeechSynthesisUtterance(CHAR_TTS[char]);
                utt.lang = 'th-TH';
                utt.rate = 0.85;
                window.speechSynthesis.speak(utt);
            }
        });
    } else if (CHAR_TTS[char]) {
        const utt = new SpeechSynthesisUtterance(CHAR_TTS[char]);
        utt.lang = 'th-TH';
        utt.rate = 0.85;
        window.speechSynthesis.speak(utt);
    }
}

function randomizeChar() {
    if (!state.gameActive) return;
    ensureAudio();

    // Online moderator: send to server
    if (state.gameType === 'online' && state.role === 'moderator') {
        wsSend({ type: 'randomize' });
        return;
    }

    const remaining = state.gamePool.filter(ch => !state.calledChars.includes(ch));
    if (remaining.length === 0) {
        setVoiceStatus(t('statusEmpty'), 'error', 'statusEmpty');
        document.getElementById('random-btn').disabled = true;
        return;
    }

    const char = remaining[Math.floor(Math.random() * remaining.length)];
    state.pendingChar = char;

    // Show "?" while pending
    const charEl = document.getElementById('current-char');
    const display = document.getElementById('caller-display');
    charEl.textContent = '?';
    display.classList.remove('has-char');

    speakChar(char);

    document.getElementById('random-btn').disabled = true;
    document.getElementById('replay-btn').classList.remove('hidden');
    document.getElementById('reveal-btn').classList.remove('hidden');
    setVoiceStatus(t('statusPending'), '', 'statusPending');
}

function replayChar() {
    // Online moderator: send to server to broadcast to all
    if (state.gameType === 'online' && state.role === 'moderator' && state.pendingChar) {
        wsSend({ type: 'replay' });
        // Also play locally for moderator
        speakChar(state.pendingChar);
        return;
    }

    // Local mode or player: just play locally
    if (state.pendingChar) speakChar(state.pendingChar);
}

function revealChar() {
    if (!state.pendingChar) return;

    // Online moderator: send to server
    if (state.gameType === 'online' && state.role === 'moderator') {
        if (charVoiceover) { charVoiceover.pause(); charVoiceover.currentTime = 0; }
        wsSend({ type: 'reveal' });
        return;
    }

    if (charVoiceover) { charVoiceover.pause(); charVoiceover.currentTime = 0; }
    const char = state.pendingChar;
    state.pendingChar = null;
    document.getElementById('reveal-btn').classList.add('hidden');
    document.getElementById('replay-btn').classList.add('hidden');
    callCharacter(char);

    // Validate pending selections
    const selections = { ...state.pendingSelections };
    state.pendingSelections = {};

    for (const pi in selections) {
        const { r, c } = selections[pi];
        const cell = state.boards[pi][r][c];
        const el = document.getElementById(`cell-${pi}-${r}-${c}`);
        if (cell.char === char) {
            confirmMark(parseInt(pi), r, c);
        } else {
            el.classList.remove('selected');
            el.classList.add('wrong');
            sfxWrong();
            setTimeout(() => el.classList.remove('wrong'), 350);
        }
    }

    // Re-enable randomize if pool not exhausted
    const remaining = state.gamePool.filter(ch => !state.calledChars.includes(ch));
    if (remaining.length > 0) {
        document.getElementById('random-btn').disabled = false;
        setVoiceStatus(t('statusNext'), 'success', 'statusNext');
    } else {
        document.getElementById('random-btn').disabled = true;
        setVoiceStatus(t('statusEmpty'), '', 'statusEmpty');
    }
}

function setVoiceStatus(text, type, i18nKey) {
    const el = document.getElementById('voice-status');
    el.textContent = text;
    el.className = 'voice-status' + (type ? ' ' + type : '');
    if (i18nKey) el.dataset.statusKey = i18nKey;
}

// ============================================================
// CHARACTER CALLING
// ============================================================
function callCharacter(char) {
    if (!state.gameActive) return;
    if (state.calledChars.includes(char)) return;

    state.currentChar = char;
    state.calledChars.push(char);

    sfxCall();

    // Update display
    const display = document.getElementById('caller-display');
    const charEl = document.getElementById('current-char');
    charEl.textContent = char;
    display.classList.remove('pop', 'has-char');
    void display.offsetWidth;
    display.classList.add('pop', 'has-char');

    document.getElementById('draw-count').textContent = state.calledChars.length;
    renderCalledHistory();
    updateHints();
}

// ============================================================
// SETUP UI
// ============================================================
function initSetup() {
    // --- Game type toggle ---
    let gtContainer = document.getElementById('game-type-btns');
    if (!gtContainer) {
        const section = document.createElement('div');
        section.className = 'setup-section';
        section.id = 'game-type-section';
        const label = document.createElement('label');
        label.setAttribute('data-i18n', 'gameType');
        label.textContent = t('gameType');
        section.appendChild(label);
        gtContainer = document.createElement('div');
        gtContainer.className = 'btn-group';
        gtContainer.id = 'game-type-btns';
        section.appendChild(gtContainer);
        const setupContainer = document.querySelector('.setup-container');
        setupContainer.insertBefore(section, setupContainer.querySelector('.setup-section'));
    }
    gtContainer.innerHTML = '';
    [{key:'local',i18n:'gameTypeLocal'},{key:'online',i18n:'gameTypeOnline'}].forEach(g => {
        const btn = document.createElement('button');
        btn.textContent = t(g.i18n);
        btn.className = g.key === state.gameType ? 'active' : '';
        btn.onclick = () => { state.gameType = g.key; initSetup(); };
        gtContainer.appendChild(btn);
    });

    // --- Show/hide sections based on game type ---
    const localSections = ['player-count-btns', 'name-inputs'].map(id => document.getElementById(id)?.closest('.setup-section'));
    const startBtn = document.querySelector('.start-button');

    // Remove old online section if exists
    const oldOnline = document.getElementById('online-setup-section');
    if (oldOnline) oldOnline.remove();

    if (state.gameType === 'local') {
        localSections.forEach(s => { if (s) s.classList.remove('hidden'); });
        startBtn.classList.remove('hidden');
        startBtn.textContent = t('startGame');
        startBtn.onclick = () => startGame();
    } else {
        localSections.forEach(s => { if (s) s.classList.add('hidden'); });
        startBtn.classList.add('hidden');
        renderOnlineSetup();
    }

    // --- Player count (local only) ---
    const pcContainer = document.getElementById('player-count-btns');
    pcContainer.innerHTML = '';
    [2, 3, 4].forEach(n => {
        const btn = document.createElement('button');
        btn.textContent = n + ' ' + t('playerUnit');
        btn.className = n === state.playerCount ? 'active' : '';
        btn.onclick = () => { state.playerCount = n; initSetup(); };
        pcContainer.appendChild(btn);
    });

    // --- Name inputs (local only) ---
    const nameContainer = document.getElementById('name-inputs');
    nameContainer.innerHTML = '';
    for (let i = 0; i < state.playerCount; i++) {
        const row = document.createElement('div');
        row.className = 'name-input-row';
        const dot = document.createElement('div');
        dot.className = 'color-dot';
        dot.style.background = PLAYER_COLORS[i];
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = t('defaultPlayer') + ' ' + (i + 1);
        input.id = 'name-' + i;
        if (state.players[i]) input.value = state.players[i];
        row.appendChild(dot);
        row.appendChild(input);
        nameContainer.appendChild(row);
    }

    // --- Mode buttons ---
    const modeContainer = document.getElementById('mode-btns');
    modeContainer.innerHTML = '';
    [{ key: 'consonants', i18n: 'modeConsonants' }, { key: 'vowels', i18n: 'modeVowels' }, { key: 'mixed', i18n: 'modeMixed' }].forEach(m => {
        const btn = document.createElement('button');
        btn.textContent = t(m.i18n);
        btn.className = m.key === state.mode ? 'active' : '';
        btn.onclick = () => { state.mode = m.key; initSetup(); };
        modeContainer.appendChild(btn);
    });
}

function renderOnlineSetup() {
    const container = document.querySelector('.setup-container');
    const section = document.createElement('div');
    section.id = 'online-setup-section';

    // Role toggle: Create / Join
    const roleSection = document.createElement('div');
    roleSection.className = 'setup-section';
    const roleLabel = document.createElement('label');
    roleLabel.textContent = t('onlineRole');
    roleSection.appendChild(roleLabel);
    const roleGroup = document.createElement('div');
    roleGroup.className = 'btn-group';
    [{key:'create',i18n:'createRoom'},{key:'join',i18n:'joinRoom'}].forEach(r => {
        const btn = document.createElement('button');
        btn.textContent = t(r.i18n);
        btn.className = r.key === state.onlineRole ? 'active' : '';
        btn.onclick = () => { state.onlineRole = r.key; initSetup(); };
        roleGroup.appendChild(btn);
    });
    roleSection.appendChild(roleGroup);
    section.appendChild(roleSection);

    if (state.onlineRole === 'create') {
        // Name input
        const nameDiv = document.createElement('div');
        nameDiv.className = 'online-setup-section';
        const nameLabel = document.createElement('label');
        nameLabel.textContent = t('moderatorName');
        nameDiv.appendChild(nameLabel);
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.id = 'moderator-name';
        nameInput.placeholder = t('moderatorName');
        nameDiv.appendChild(nameInput);
        section.appendChild(nameDiv);

        // Create button
        const createBtn = document.createElement('button');
        createBtn.type = 'button';
        createBtn.className = 'start-button';
        createBtn.textContent = t('createRoomBtn');
        createBtn.onclick = () => createRoom();
        section.appendChild(createBtn);
    } else {
        // Room code input
        const codeDiv = document.createElement('div');
        codeDiv.className = 'online-setup-section';
        const codeLabel = document.createElement('label');
        codeLabel.textContent = t('roomCodeLabel');
        codeDiv.appendChild(codeLabel);
        const codeInput = document.createElement('input');
        codeInput.type = 'text';
        codeInput.id = 'join-room-code';
        codeInput.className = 'room-code-input';
        codeInput.placeholder = t('roomCodePlaceholder');
        codeInput.maxLength = 6;
        codeInput.oninput = () => { codeInput.value = codeInput.value.toUpperCase().replace(/[^A-Z0-9]/g,''); };
        codeDiv.appendChild(codeInput);
        section.appendChild(codeDiv);

        // Auto-fill from URL ?room= param
        const urlRoom = new URLSearchParams(location.search).get('room');
        if (urlRoom) {
            setTimeout(() => {
                const el = document.getElementById('join-room-code');
                if (el && !el.value) el.value = urlRoom.toUpperCase();
            }, 0);
        }

        // Name input
        const nameDiv = document.createElement('div');
        nameDiv.className = 'online-setup-section';
        const nameLabel = document.createElement('label');
        nameLabel.textContent = t('joinName');
        nameDiv.appendChild(nameLabel);
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.id = 'join-player-name';
        nameInput.placeholder = t('joinName');
        nameDiv.appendChild(nameInput);
        section.appendChild(nameDiv);

        // Join button
        const joinBtn = document.createElement('button');
        joinBtn.type = 'button';
        joinBtn.className = 'start-button';
        joinBtn.textContent = t('joinBtn');
        joinBtn.onclick = () => joinRoom();
        section.appendChild(joinBtn);
    }

    // Insert before the mode section (which is hidden) or at the end
    const hintsToggle = container.querySelector('.hint-toggle');
    container.insertBefore(section, hintsToggle);
}

// ============================================================
// GAME SETUP
// ============================================================
function startGame() {
    ensureAudio();

    state.players = [];
    for (let i = 0; i < state.playerCount; i++) {
        const input = document.getElementById('name-' + i);
        state.players.push(input && input.value.trim() ? input.value.trim() : t('defaultPlayer') + ' ' + (i + 1));
    }
    state.hintsOn = document.getElementById('hints-check').checked;

    // Build character pool
    let fullPool;
    if (state.mode === 'consonants') fullPool = [...CONSONANTS];
    else if (state.mode === 'vowels') fullPool = [...VOWELS];
    else fullPool = [...CONSONANTS, ...VOWELS];

    const poolSize = Math.min(GAME_POOL_SIZES[state.mode], fullPool.length);
    state.gamePool = shuffle(fullPool).slice(0, poolSize);
    state.calledChars = [];
    state.currentChar = null;
    state.pendingChar = null;
    state.pendingSelections = {};
    state.winners = [];
    state.gameActive = true;

    // Generate boards
    state.boards = [];
    for (let p = 0; p < state.playerCount; p++) {
        state.boards.push(generateBoard(state.gamePool));
    }

    renderGame();
    document.getElementById('setup-screen').classList.add('hidden');
    document.getElementById('game-screen').classList.remove('hidden');
    document.getElementById('win-overlay').classList.add('hidden');

    // Reset randomize/replay/reveal button states
    document.getElementById('random-btn').disabled = false;
    document.getElementById('replay-btn').classList.add('hidden');
    document.getElementById('reveal-btn').classList.add('hidden');
    setVoiceStatus(t('statusReady'), '', 'statusReady');
}

function generateBoard(pool) {
    const picked = shuffle(pool).slice(0, 24);
    const board = [];
    let idx = 0;
    for (let r = 0; r < 5; r++) {
        const row = [];
        for (let c = 0; c < 5; c++) {
            if (r === 2 && c === 2) {
                row.push({ char: '‚≠ê', marked: true, free: true });
            } else {
                row.push({ char: picked[idx++], marked: false, free: false });
            }
        }
        board.push(row);
    }
    return board;
}

// ============================================================
// RENDERING
// ============================================================
function renderGame() {
    document.getElementById('total-count').textContent = state.gamePool.length;
    document.getElementById('draw-count').textContent = state.calledChars.length;
    document.getElementById('current-char').textContent = state.currentChar || '?';

    const display = document.getElementById('caller-display');
    if (state.currentChar) display.classList.add('has-char');
    else display.classList.remove('has-char');

    renderCalledHistory();
    renderBoards();
}

function renderCalledHistory() {
    const container = document.getElementById('called-history');
    container.innerHTML = '';
    state.calledChars.forEach(ch => {
        const chip = document.createElement('span');
        chip.className = 'called-chip ' + (isVowel(ch) ? 'vowel' : 'consonant');
        chip.textContent = ch;
        container.appendChild(chip);
    });
    container.scrollTop = container.scrollHeight;
}

function renderBoards() {
    const container = document.getElementById('boards-container');
    container.innerHTML = '';

    const isOnline = state.gameType === 'online';
    const hasOwnBoard = isOnline && state.myBoardId;
    const isPlayerView = isOnline && (state.role === 'player' || (state.role === 'moderator' && state.moderatorPlaying));

    if (isPlayerView) {
        container.className = 'boards-container online-player';
    } else {
        container.className = 'boards-container players-' + state.playerCount;
    }

    let secondaryRow = null;
    if (isPlayerView && state.boards.length > 1) {
        secondaryRow = document.createElement('div');
        secondaryRow.className = 'secondary-boards-row';
    }

    state.boards.forEach((board, pi) => {
        const isPrimary = isPlayerView && pi === 0; // own board is first
        const isSecondary = isPlayerView && pi > 0;

        const card = document.createElement('div');
        card.className = 'board-card p' + (pi % 4);
        if (isOnline && state._boardIdMap) card.dataset.playerId = state._boardIdMap[pi] || '';
        if (isPrimary) card.classList.add('primary');
        if (isSecondary) card.classList.add('secondary');

        const header = document.createElement('div');
        header.className = 'board-header';
        header.textContent = state.players[pi];
        card.appendChild(header);

        const grid = document.createElement('div');
        grid.className = 'board-grid';

        for (let r = 0; r < 5; r++) {
            for (let c = 0; c < 5; c++) {
                const cell = board[r][c];
                const el = document.createElement('div');
                el.className = 'cell';
                el.id = `cell-${pi}-${r}-${c}`;
                el.textContent = cell.char;

                if (cell.free) el.classList.add('free');
                if (cell.marked && !cell.free) el.classList.add('marked');

                // Only allow clicking own board cells (or all in local mode)
                const canClick = !isOnline || (hasOwnBoard && state._boardIdMap[pi] === state.myBoardId);
                if (!cell.free && !cell.marked && canClick) {
                    el.onclick = () => markCell(pi, r, c);
                }

                grid.appendChild(el);
            }
        }

        card.appendChild(grid);

        if (isSecondary && secondaryRow) {
            secondaryRow.appendChild(card);
        } else {
            container.appendChild(card);
        }
    });

    if (secondaryRow && secondaryRow.children.length > 0) {
        container.appendChild(secondaryRow);
    }

    updateHints();
}

function updateHints() {
    if (!state.hintsOn) return;
    state.boards.forEach((board, pi) => {
        for (let r = 0; r < 5; r++) {
            for (let c = 0; c < 5; c++) {
                const cell = board[r][c];
                const el = document.getElementById(`cell-${pi}-${r}-${c}`);
                if (!el) continue;
                if (!cell.marked && !cell.free && state.calledChars.includes(cell.char)) {
                    el.classList.add('hint-pulse');
                } else {
                    el.classList.remove('hint-pulse');
                }
            }
        }
    });
}

// ============================================================
// MARKING & WIN
// ============================================================
function markCell(pi, r, c) {
    if (!state.gameActive) return;
    ensureAudio();

    const cell = state.boards[pi][r][c];
    if (cell.marked || cell.free) return;

    // Online mode: only allow marking own board
    if (state.gameType === 'online') {
        const boardPlayerId = state._boardIdMap[pi];
        if (boardPlayerId !== state.myBoardId) return; // can't click other boards

        if (state.pendingChar) {
            // Tentative selection ‚Äî visual only, send to server
            const prev = state.pendingSelections[pi];
            if (prev) {
                const prevEl = document.getElementById(`cell-${pi}-${prev.r}-${prev.c}`);
                if (prevEl) prevEl.classList.remove('selected');
            }
            if (prev && prev.r === r && prev.c === c) {
                delete state.pendingSelections[pi];
                wsSend({ type: 'select', r, c }); // toggle off
            } else {
                state.pendingSelections[pi] = { pi, r, c };
                const el = document.getElementById(`cell-${pi}-${r}-${c}`);
                el.classList.add('selected');
                sfxMark();
                wsSend({ type: 'select', r, c });
            }
            return;
        }

        // Mark already-called character
        if (state.calledChars.includes(cell.char)) {
            wsSend({ type: 'mark', r, c });
        } else {
            sfxWrong();
            const el = document.getElementById(`cell-${pi}-${r}-${c}`);
            el.classList.add('wrong');
            setTimeout(() => el.classList.remove('wrong'), 350);
        }
        return;
    }

    // Local mode ‚Äî existing behavior
    if (state.pendingChar) {
        const prev = state.pendingSelections[pi];
        if (prev) {
            const prevEl = document.getElementById(`cell-${prev.pi}-${prev.r}-${prev.c}`);
            if (prevEl) prevEl.classList.remove('selected');
        }
        if (prev && prev.r === r && prev.c === c) {
            delete state.pendingSelections[pi];
        } else {
            state.pendingSelections[pi] = { pi, r, c };
            const el = document.getElementById(`cell-${pi}-${r}-${c}`);
            el.classList.add('selected');
            sfxMark();
        }
        return;
    }

    if (!state.calledChars.includes(cell.char)) {
        sfxWrong();
        const el = document.getElementById(`cell-${pi}-${r}-${c}`);
        el.classList.add('wrong');
        setTimeout(() => el.classList.remove('wrong'), 350);
        return;
    }

    confirmMark(pi, r, c);
}

function confirmMark(pi, r, c) {
    const cell = state.boards[pi][r][c];
    cell.marked = true;
    sfxMark();

    const el = document.getElementById(`cell-${pi}-${r}-${c}`);
    el.classList.remove('selected', 'hint-pulse');
    el.classList.add('marked', 'mark-anim');
    el.onclick = null;
    setTimeout(() => el.classList.remove('mark-anim'), 400);

    const winLine = checkWin(pi);
    if (winLine && !state.winners.includes(pi)) {
        state.winners.push(pi);
        highlightWinLine(pi, winLine);
        setTimeout(() => showWin(pi), 500);
    }
}

function checkWin(pi) {
    const board = state.boards[pi];
    for (let r = 0; r < 5; r++) {
        if (board[r].every(cell => cell.marked)) return board[r].map((_, c) => [r, c]);
    }
    for (let c = 0; c < 5; c++) {
        if (board.every(row => row[c].marked)) return board.map((_, r) => [r, c]);
    }
    if ([0,1,2,3,4].every(i => board[i][i].marked)) return [0,1,2,3,4].map(i => [i, i]);
    if ([0,1,2,3,4].every(i => board[i][4-i].marked)) return [0,1,2,3,4].map(i => [i, 4-i]);
    return null;
}

function highlightWinLine(pi, line) {
    line.forEach(([r, c]) => {
        const el = document.getElementById(`cell-${pi}-${r}-${c}`);
        if (el) el.classList.add('win-glow');
    });
}

// ============================================================
// WIN / CONTINUE / RESET
// ============================================================
function showWin(pi) {
    sfxWin();
    state.gameActive = false;
    if (charVoiceover) { charVoiceover.pause(); charVoiceover.currentTime = 0; }
    document.getElementById('winner-name').textContent = state.players[pi];
    document.getElementById('win-overlay').classList.remove('hidden');
    startConfetti();
}

function continueAfterWin() {
    stopConfetti();
    document.getElementById('win-overlay').classList.add('hidden');
    state.gameActive = true;
}

function resetGame() {
    stopConfetti();
    if (charVoiceover) { charVoiceover.pause(); charVoiceover.currentTime = 0; }
    document.getElementById('win-overlay').classList.add('hidden');
    if (state.gameType === 'online') {
        if (state.role === 'moderator') {
            wsSend({ type: 'start', moderatorPlaying: state.moderatorPlaying });
        }
        return;
    }
    startGame();
}

function backToSetup() {
    stopConfetti();
    if (charVoiceover) { charVoiceover.pause(); charVoiceover.currentTime = 0; }
    // Close WebSocket if online
    if (state.ws) { state.ws.close(); state.ws = null; }
    state.gameType = 'local';
    state.role = null;
    state.roomCode = null;
    state.onlinePhase = null;
    // Remove online status banner if present
    const banner = document.getElementById('online-status-banner');
    if (banner) banner.remove();
    // Show caller section again
    document.querySelector('.caller-section').classList.remove('hidden');

    document.getElementById('win-overlay').classList.add('hidden');
    document.getElementById('game-screen').classList.add('hidden');
    document.getElementById('lobby-screen').classList.add('hidden');
    document.getElementById('setup-screen').classList.remove('hidden');
}

// ============================================================
// CONFETTI
// ============================================================
function startConfetti() {
    const canvas = document.getElementById('confetti-canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const colors = ['#ef4444','#f97316','#eab308','#22c55e','#3b82f6','#8b5cf6','#ec4899','#06b6d4'];
    const particles = Array.from({ length: 180 }, () => ({
        x: Math.random() * canvas.width,
        y: Math.random() * -canvas.height,
        w: Math.random() * 10 + 5, h: Math.random() * 6 + 3,
        color: colors[Math.floor(Math.random() * colors.length)],
        speed: Math.random() * 3 + 2,
        angle: Math.random() * Math.PI * 2,
        spin: (Math.random() - 0.5) * 0.15,
        drift: (Math.random() - 0.5) * 1.5,
        opacity: Math.random() * 0.5 + 0.5
    }));
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        particles.forEach(p => {
            ctx.save(); ctx.globalAlpha = p.opacity;
            ctx.translate(p.x, p.y); ctx.rotate(p.angle);
            ctx.fillStyle = p.color;
            ctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
            ctx.restore();
            p.y += p.speed; p.x += p.drift; p.angle += p.spin;
            if (p.y > canvas.height + 20) { p.y = -20; p.x = Math.random() * canvas.width; }
        });
        state.confettiId = requestAnimationFrame(draw);
    }
    draw();
}
function stopConfetti() {
    if (state.confettiId) { cancelAnimationFrame(state.confettiId); state.confettiId = null; }
    const canvas = document.getElementById('confetti-canvas');
    canvas.getContext('2d').clearRect(0, 0, canvas.width, canvas.height);
}

// ============================================================
// ONLINE MODE ‚Äî WebSocket Client
// ============================================================

async function createRoom() {
    const nameInput = document.getElementById('moderator-name');
    const name = nameInput?.value.trim() || t('defaultPlayer') + ' 1';

    try {
        const resp = await fetch(API_BASE + '/api/room', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                name,
                mode: state.mode,
                hintsOn: document.getElementById('hints-check').checked,
                playing: false, // Will be set in lobby
            }),
        });
        if (!resp.ok) {
            throw new Error(`HTTP ${resp.status}`);
        }
        const data = await resp.json();
        state.roomCode = data.room;
        state.playerId = data.moderatorId;
        state.role = 'moderator';
        state.onlinePhase = 'lobby';
        state.onlinePlayers = [];
        state.moderatorPlaying = false; // Reset to false, will be toggled in lobby

        connectWebSocket();
        showLobby();
    } catch (e) {
        alert(t('errorConnection'));
    }
}

function joinRoom() {
    const code = document.getElementById('join-room-code')?.value.trim().toUpperCase();
    const name = document.getElementById('join-player-name')?.value.trim() || t('defaultPlayer');
    if (!code || code.length !== 6) return;

    state.roomCode = code;
    state.playerId = Math.random().toString(36).slice(2, 10);
    state.role = 'player';
    state.onlinePhase = 'lobby';
    state._joinName = name;

    connectWebSocket();
    showLobby();
}

function connectWebSocket() {
    const wsBase = API_BASE.replace(/^http/, 'ws');
    const params = new URLSearchParams({
        role: state.role,
        id: state.playerId,
        name: state._joinName || '',
    });
    const url = `${wsBase}/api/room/${state.roomCode}/websocket?${params}`;
    const ws = new WebSocket(url);

    ws.onopen = () => {
        state.ws = ws;
    };

    ws.onmessage = (event) => {
        const msg = JSON.parse(event.data);
        handleServerMessage(msg);
    };

    ws.onclose = () => {
        state.ws = null;
        // Try reconnect after 2s if still in online mode
        if (state.gameType === 'online' && state.roomCode) {
            setTimeout(() => {
                if (state.gameType === 'online' && !state.ws) {
                    connectWebSocket();
                }
            }, 2000);
        }
    };

    ws.onerror = () => {
        ws.close();
    };
}

function wsSend(msg) {
    if (state.ws && state.ws.readyState === WebSocket.OPEN) {
        state.ws.send(JSON.stringify(msg));
    }
}

function handleServerMessage(msg) {
    switch (msg.type) {
        case 'joined':
            state.playerId = msg.playerId;
            state.onlinePlayers = msg.players || [];
            state.onlinePhase = msg.phase || 'lobby';
            renderLobbyPlayers();
            break;

        case 'player_joined':
            state.onlinePlayers = msg.players || [];
            renderLobbyPlayers();
            break;

        case 'player_disconnected':
            markPlayerConnection(msg.playerId, false);
            break;

        case 'player_reconnected':
            markPlayerConnection(msg.playerId, true);
            break;

        case 'moderator_disconnected':
            // Show a banner or alert
            break;

        case 'game_start':
            onlineGameStart(msg);
            break;

        case 'randomized':
            // Moderator only ‚Äî gets the pending char
            onlineRandomized(msg.pendingChar);
            break;

        case 'char_pending':
            // Players ‚Äî a char was randomized, they should select
            onlineCharPending(msg.char);
            break;

        case 'char_pending_moderator':
            // Moderator playing ‚Äî also announce the char they already received
            if (msg.char) speakChar(msg.char);
            break;

        case 'char_replay':
            // All participants ‚Äî replay the character audio
            if (msg.char) speakChar(msg.char);
            break;

        case 'revealed':
            onlineRevealed(msg);
            break;

        case 'mark_result':
            onlineMarkResult(msg);
            break;

        case 'win':
            onlineWin(msg);
            break;

        case 'ready_update':
            state.pendingReadyIds = msg.readyPlayerIds || [];
            state.isReady = state.pendingReadyIds.includes(state.playerId);
            updateReadyButton();
            updateReadyIndicators();
            if (state.role === 'moderator') updateModeratorReadyInfo();
            break;

        case 'error':
            alert(msg.message);
            break;
    }
}

function markPlayerConnection(playerId, connected) {
    const p = state.onlinePlayers.find(p => p.id === playerId);
    if (p) p.connected = connected;
    renderLobbyPlayers();
}

// ============================================================
// ONLINE MODE ‚Äî Lobby
// ============================================================

function showLobby() {
    document.getElementById('setup-screen').classList.add('hidden');
    document.getElementById('game-screen').classList.add('hidden');
    document.getElementById('lobby-screen').classList.remove('hidden');

    const title = document.getElementById('lobby-title');
    const code = document.getElementById('lobby-room-code');
    const subtitle = document.getElementById('lobby-subtitle');
    const shareRow = document.getElementById('share-link-row');
    const startBtn = document.getElementById('lobby-start-btn');
    const waitingMsg = document.getElementById('lobby-waiting-msg');
    const playToggle = document.getElementById('moderator-play-toggle');
    const playCheckbox = document.getElementById('lobby-moderator-plays');

    code.textContent = state.roomCode;

    if (state.role === 'moderator') {
        title.textContent = t('yourRoom');
        subtitle.textContent = t('waitingForPlayers');
        shareRow.classList.remove('hidden');
        const shareUrl = location.origin + location.pathname + '?room=' + state.roomCode;
        document.getElementById('share-link-input').value = shareUrl;
        document.getElementById('copy-link-btn').textContent = t('copyLink');
        startBtn.textContent = t('startGameOnline');
        startBtn.classList.remove('hidden');
        startBtn.disabled = true;
        waitingMsg.classList.add('hidden');

        // Show moderator play toggle
        playToggle.classList.remove('hidden');
        playCheckbox.checked = state.moderatorPlaying;
        if (state.moderatorPlaying) {
            playToggle.classList.add('active');
        } else {
            playToggle.classList.remove('active');
        }
    } else {
        title.textContent = t('youJoinedAs') + ' ' + (state._joinName || '');
        subtitle.textContent = t('waitingForPlayers');
        shareRow.classList.add('hidden');
        startBtn.classList.add('hidden');
        waitingMsg.textContent = t('waitingForModerator');
        waitingMsg.classList.remove('hidden');
        playToggle.classList.add('hidden');
    }

    renderLobbyPlayers();
}

function toggleModeratorPlaying(event) {
    const checkbox = document.getElementById('lobby-moderator-plays');
    const toggle = document.getElementById('moderator-play-toggle');

    // If checkbox was clicked directly, it already toggled - just update state
    // If wrapper was clicked, manually toggle the checkbox
    if (event && event.target !== checkbox) {
        checkbox.checked = !checkbox.checked;
    }

    // Update state to match checkbox
    state.moderatorPlaying = checkbox.checked;

    // Update visual style
    if (state.moderatorPlaying) {
        toggle.classList.add('active');
    } else {
        toggle.classList.remove('active');
    }

    // Update start button enabled state based on new player count requirements
    renderLobbyPlayers();
}

function renderLobbyPlayers() {
    const list = document.getElementById('lobby-player-list');
    if (!list) return;
    list.innerHTML = '';

    state.onlinePlayers.forEach((p, i) => {
        const item = document.createElement('div');
        item.className = 'player-list-item';

        const dot = document.createElement('div');
        dot.className = 'color-dot';
        dot.style.background = PLAYER_COLORS[i % PLAYER_COLORS.length];
        item.appendChild(dot);

        const name = document.createElement('span');
        name.className = 'player-name';
        name.textContent = p.name;
        item.appendChild(name);

        if (p.id === state.playerId) {
            const badge = document.createElement('span');
            badge.className = 'you-badge';
            badge.textContent = t('you');
            item.appendChild(badge);
        }

        const connDot = document.createElement('div');
        connDot.className = 'connection-dot ' + (p.connected !== false ? 'online' : 'offline');
        item.appendChild(connDot);

        list.appendChild(item);
    });

    // Update subtitle with player count (both roles)
    const subtitle = document.getElementById('lobby-subtitle');
    const count = state.onlinePlayers.length;
    if (subtitle) {
        subtitle.textContent = count === 0
            ? t('waitingForPlayers')
            : t('lobbyPlayerCount').replace('{n}', count);
    }

    // Update start button enable state (moderator only)
    if (state.role === 'moderator') {
        const startBtn = document.getElementById('lobby-start-btn');
        const minNeeded = state.moderatorPlaying ? 1 : 2;
        if (startBtn) startBtn.disabled = count < minNeeded;
    }
}

function copyShareLink() {
    const input = document.getElementById('share-link-input');
    navigator.clipboard.writeText(input.value).then(() => {
        const btn = document.getElementById('copy-link-btn');
        btn.textContent = t('linkCopied');
        btn.classList.add('copied');
        setTimeout(() => {
            btn.textContent = t('copyLink');
            btn.classList.remove('copied');
        }, 2000);
    });
}

function onlineStartGame() {
    wsSend({ type: 'start', moderatorPlaying: state.moderatorPlaying });
}

// ============================================================
// ONLINE MODE ‚Äî Game
// ============================================================

function onlineGameStart(msg) {
    ensureAudio();

    state.onlinePhase = 'playing';
    state.allBoards = msg.boards;
    state.gamePool = msg.gamePool;
    state.onlinePlayers = msg.players;
    state.myBoardId = msg.yourBoardId;
    state.hintsOn = msg.hintsOn;
    state.calledChars = msg.calledChars || [];
    state.currentChar = msg.currentChar || null;
    state.winners = msg.winners || [];
    state.gameActive = true;
    state.pendingChar = msg.pendingChar || null;
    state.pendingSelections = {};
    state.pendingReadyIds = msg.pendingReadyIds || [];
    state.isReady = state.pendingReadyIds.includes(state.playerId);

    // Build boards array + players array for rendering
    const playerIds = Object.keys(state.allBoards);
    state.boards = [];
    state.players = [];
    state._boardIdMap = {};  // index ‚Üí playerId
    state._boardIndexMap = {}; // playerId ‚Üí index

    // For player view: own board first, then others
    if (state.role === 'player' || (state.role === 'moderator' && state.moderatorPlaying)) {
        // Own board first
        if (state.myBoardId && state.allBoards[state.myBoardId]) {
            const idx = state.boards.length;
            state.boards.push(state.allBoards[state.myBoardId]);
            const info = state.onlinePlayers.find(p => p.id === state.myBoardId);
            state.players.push(info ? info.name : t('you'));
            state._boardIdMap[idx] = state.myBoardId;
            state._boardIndexMap[state.myBoardId] = idx;
        }
        // Others
        for (const pid of playerIds) {
            if (pid === state.myBoardId) continue;
            const idx = state.boards.length;
            state.boards.push(state.allBoards[pid]);
            const info = state.onlinePlayers.find(p => p.id === pid);
            state.players.push(info ? info.name : pid);
            state._boardIdMap[idx] = pid;
            state._boardIndexMap[pid] = idx;
        }
    } else {
        // Moderator (not playing) ‚Äî all boards equal
        for (const pid of playerIds) {
            const idx = state.boards.length;
            state.boards.push(state.allBoards[pid]);
            const info = state.onlinePlayers.find(p => p.id === pid);
            state.players.push(info ? info.name : pid);
            state._boardIdMap[idx] = pid;
            state._boardIndexMap[pid] = idx;
        }
    }

    state.playerCount = state.boards.length;

    // Show game screen
    document.getElementById('lobby-screen').classList.add('hidden');
    document.getElementById('setup-screen').classList.add('hidden');
    document.getElementById('game-screen').classList.remove('hidden');
    document.getElementById('win-overlay').classList.add('hidden');

    // Caller section visibility
    const callerSection = document.querySelector('.caller-section');
    if (state.role === 'moderator') {
        callerSection.classList.remove('hidden');
    } else {
        callerSection.classList.add('hidden');
    }

    renderGame();
    renderOnlineStatusBanner();

    document.getElementById('random-btn').disabled = false;
    document.getElementById('replay-btn').classList.add('hidden');
    document.getElementById('reveal-btn').classList.add('hidden');
    setVoiceStatus(t('statusReady'), '', 'statusReady');

    // Restore ready UI on reconnect during pending phase
    if (state.pendingChar) {
        renderReadyButton();
        updateReadyButton();
        updateReadyIndicators();
        if (state.role === 'moderator') {
            document.getElementById('random-btn').disabled = true;
            document.getElementById('replay-btn').classList.remove('hidden');
            document.getElementById('reveal-btn').classList.remove('hidden');
            setVoiceStatus(t('statusPending'), '', 'statusPending');
            updateModeratorReadyInfo();
        }
    }
}

function renderOnlineStatusBanner() {
    if (state.gameType !== 'online' || state.role === 'moderator') return;

    let banner = document.getElementById('online-status-banner');
    if (!banner) {
        banner = document.createElement('div');
        banner.className = 'status-banner';
        banner.id = 'online-status-banner';
        const gameScreen = document.getElementById('game-screen');
        gameScreen.insertBefore(banner, gameScreen.firstChild);
    }

    if (state.pendingChar) {
        banner.textContent = t('statusSelectYourCell');
        banner.className = 'status-banner selecting';
    } else if (state.currentChar) {
        banner.textContent = t('statusCharRevealed');
        banner.className = 'status-banner revealed';
    } else {
        banner.textContent = t('statusModeratorRandomizing');
        banner.className = 'status-banner pending';
    }
}

function renderReadyButton() {
    if (state.gameType !== 'online') return;
    const isParticipant = state.role === 'player' || (state.role === 'moderator' && state.moderatorPlaying);
    if (!isParticipant) return;

    removeReadyButton();
    const btn = document.createElement('button');
    btn.className = 'ready-button';
    btn.id = 'ready-btn';
    btn.textContent = t('readyBtn');
    btn.onclick = () => {
        wsSend({ type: 'ready' });
    };

    const gameScreen = document.getElementById('game-screen');
    const boardsContainer = document.getElementById('boards-container');
    gameScreen.insertBefore(btn, boardsContainer);
}

function removeReadyButton() {
    const btn = document.getElementById('ready-btn');
    if (btn) btn.remove();
}

function updateReadyButton() {
    const btn = document.getElementById('ready-btn');
    if (!btn) return;
    if (state.isReady) {
        btn.classList.add('active');
        btn.textContent = '\u2714 ' + t('readyBtn');
    } else {
        btn.classList.remove('active');
        btn.textContent = t('readyBtn');
    }
}

function updateReadyIndicators() {
    if (state.gameType !== 'online') return;
    const readySet = new Set(state.pendingReadyIds);
    const allCards = document.querySelectorAll('.board-card[data-player-id]');

    for (const card of allCards) {
        const pid = card.dataset.playerId;
        const header = card.querySelector('.board-header');
        if (readySet.has(pid)) {
            card.classList.add('player-ready');
            if (header && !header.querySelector('.ready-badge')) {
                const badge = document.createElement('span');
                badge.className = 'ready-badge';
                badge.textContent = t('readyStatus');
                header.appendChild(badge);
            }
        } else {
            card.classList.remove('player-ready');
            if (header) {
                const badge = header.querySelector('.ready-badge');
                if (badge) badge.remove();
            }
        }
    }
}

function updateModeratorReadyInfo() {
    if (state.role !== 'moderator') return;
    let info = document.getElementById('moderator-ready-info');
    if (!info) {
        info = document.createElement('div');
        info.className = 'ready-info';
        info.id = 'moderator-ready-info';
        const voicePanel = document.querySelector('.voice-panel');
        if (voicePanel) voicePanel.appendChild(info);
    }
    // onlinePlayers includes moderator only when playing, so length = total participants
    const totalParticipants = state.onlinePlayers.length;
    const n = state.pendingReadyIds.length;
    info.textContent = t('playersReady').replace('{n}', n).replace('{total}', totalParticipants);
}

function clearModeratorReadyInfo() {
    const info = document.getElementById('moderator-ready-info');
    if (info) info.remove();
}

function clearReadyState() {
    state.pendingReadyIds = [];
    state.isReady = false;
    removeReadyButton();
    updateReadyIndicators();
    clearModeratorReadyInfo();
}

function onlineRandomized(pendingChar) {
    // Moderator receives the actual char
    state.pendingChar = pendingChar;
    state.pendingSelections = {};
    clearReadyState();

    const charEl = document.getElementById('current-char');
    const display = document.getElementById('caller-display');
    charEl.textContent = '?';
    display.classList.remove('has-char');

    speakChar(pendingChar);

    document.getElementById('random-btn').disabled = true;
    document.getElementById('replay-btn').classList.remove('hidden');
    document.getElementById('reveal-btn').classList.remove('hidden');
    setVoiceStatus(t('statusPending'), '', 'statusPending');

    // Render ready button for playing moderator, plus ready info
    if (state.moderatorPlaying) renderReadyButton();
    updateModeratorReadyInfo();
}

function onlineCharPending(char) {
    // Players know a char is pending and receive it to announce
    state.pendingChar = char || '__hidden__';  // truthy but may be unknown
    state.pendingSelections = {};
    state.pendingReadyIds = [];
    state.isReady = false;

    // Play audio announcement for players
    if (char && state.role === 'player') {
        ensureAudio();
        speakChar(char);
    }

    renderOnlineStatusBanner();
    renderReadyButton();
}

function onlineRevealed(msg) {
    const char = msg.char;
    state.pendingChar = null;
    state.calledChars = msg.calledChars;
    state.currentChar = char;

    // Update caller display
    const display = document.getElementById('caller-display');
    const charEl = document.getElementById('current-char');
    charEl.textContent = char;
    display.classList.remove('pop', 'has-char');
    void display.offsetWidth;
    display.classList.add('pop', 'has-char');
    document.getElementById('draw-count').textContent = state.calledChars.length;
    sfxCall();
    renderCalledHistory();

    // Process selection results
    const selections = msg.selections || {};
    for (const [playerId, result] of Object.entries(selections)) {
        const pi = state._boardIndexMap[playerId];
        if (pi === undefined) continue;
        const el = document.getElementById(`cell-${pi}-${result.r}-${result.c}`);
        if (!el) continue;

        if (result.valid) {
            state.boards[pi][result.r][result.c].marked = true;
            el.classList.remove('selected', 'hint-pulse');
            el.classList.add('marked', 'mark-anim');
            el.onclick = null;
            sfxMark();
            setTimeout(() => el.classList.remove('mark-anim'), 400);
        } else {
            el.classList.remove('selected');
            el.classList.add('wrong');
            sfxWrong();
            setTimeout(() => el.classList.remove('wrong'), 350);
        }
    }

    // Clear local pending selections
    state.pendingSelections = {};

    // Re-enable moderator buttons
    if (state.role === 'moderator') {
        document.getElementById('reveal-btn').classList.add('hidden');
        document.getElementById('replay-btn').classList.add('hidden');
        const remaining = state.gamePool.filter(ch => !state.calledChars.includes(ch));
        document.getElementById('random-btn').disabled = remaining.length === 0;
        setVoiceStatus(remaining.length > 0 ? t('statusNext') : t('statusEmpty'), remaining.length > 0 ? 'success' : '', remaining.length > 0 ? 'statusNext' : 'statusEmpty');
    }

    clearReadyState();
    updateHints();
    renderOnlineStatusBanner();
}

function onlineMarkResult(msg) {
    const pi = state._boardIndexMap[msg.playerId];
    if (pi === undefined) return;
    const el = document.getElementById(`cell-${pi}-${msg.r}-${msg.c}`);
    if (!el) return;

    if (msg.valid) {
        state.boards[pi][msg.r][msg.c].marked = true;
        el.classList.remove('hint-pulse');
        el.classList.add('marked', 'mark-anim');
        el.onclick = null;
        if (msg.playerId === state.playerId) sfxMark();
        setTimeout(() => el.classList.remove('mark-anim'), 400);
    } else {
        if (msg.playerId === state.playerId) {
            el.classList.add('wrong');
            sfxWrong();
            setTimeout(() => el.classList.remove('wrong'), 350);
        }
    }
    updateHints();
}

function onlineWin(msg) {
    sfxWin();
    const pi = state._boardIndexMap[msg.playerId];
    if (pi !== undefined && msg.winLine) {
        msg.winLine.forEach(([r, c]) => {
            const el = document.getElementById(`cell-${pi}-${r}-${c}`);
            if (el) el.classList.add('win-glow');
        });
    }
    state.winners.push(msg.playerId);

    setTimeout(() => {
        if (charVoiceover) { charVoiceover.pause(); charVoiceover.currentTime = 0; }
        document.getElementById('winner-name').textContent = msg.playerName;
        document.getElementById('win-overlay').classList.remove('hidden');
        startConfetti();
    }, 500);
}

// ============================================================
// INIT
// ============================================================

// Auto-switch to online join mode if ?room= is in URL
(function() {
    const urlRoom = new URLSearchParams(location.search).get('room');
    if (urlRoom) {
        state.gameType = 'online';
        state.onlineRole = 'join';
    }
})();

applyLang();
</script>
</body>
</html>
